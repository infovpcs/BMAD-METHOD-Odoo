==================== START: bmad-kb ====================
# BMAD Knowledge Base

## INDEX OF TOPICS

- [BMAD Knowledge Base](#bmad-knowledge-base)
  - [INDEX OF TOPICS](#index-of-topics)
  - [BMAD METHOD - CORE PHILOSOPHY](#bmad-method---core-philosophy)
  - [BMAD METHOD - AGILE METHODOLOGIES OVERVIEW](#bmad-method---agile-methodologies-overview)
    - [CORE PRINCIPLES OF AGILE](#core-principles-of-agile)
    - [KEY PRACTICES IN AGILE](#key-practices-in-agile)
    - [BENEFITS OF AGILE](#benefits-of-agile)
  - [BMAD METHOD - ANALOGIES WITH AGILE PRINCIPLES](#bmad-method---analogies-with-agile-principles)
  - [BMAD METHOD - TOOLING AND RESOURCE LOCATIONS](#bmad-method---tooling-and-resource-locations)
  - [BMAD METHOD - COMMUNITY AND CONTRIBUTIONS](#bmad-method---community-and-contributions)
    - [Licensing](#licensing)
  - [BMAD METHOD - ETHOS \& BEST PRACTICES](#bmad-method---ethos--best-practices)
  - [AGENT ROLES AND RESPONSIBILITIES](#agent-roles-and-responsibilities)
  - [NAVIGATING THE BMAD WORKFLOW - INITIAL GUIDANCE](#navigating-the-bmad-workflow---initial-guidance)
    - [STARTING YOUR PROJECT - ANALYST OR PM?](#starting-your-project---analyst-or-pm)
    - [UNDERSTANDING EPICS - SINGLE OR MULTIPLE?](#understanding-epics---single-or-multiple)
  - [GETTING STARTED WITH BMAD](#getting-started-with-bmad)
    - [Initial Project Setup](#initial-project-setup)
    - [Exporting Artifacts from AI Platforms](#exporting-artifacts-from-ai-platforms)
    - [Document Sharding](#document-sharding)
    - [Utilizing Dedicated IDE Agents (SM and Dev)](#utilizing-dedicated-ide-agents-sm-and-dev)
    - [When to Use the BMAD IDE Orchestrator](#when-to-use-the-bmad-ide-orchestrator)
  - [SUGGESTED ORDER OF AGENT ENGAGEMENT (TYPICAL FLOW)](#suggested-order-of-agent-engagement-typical-flow)
  - [HANDLING MAJOR CHANGES](#handling-major-changes)
  - [IDE VS UI USAGE - GENERAL RECOMMENDATIONS](#ide-vs-ui-usage---general-recommendations)
    - [CONCEPTUAL AND PLANNING PHASES](#conceptual-and-planning-phases)
    - [TECHNICAL DESIGN, DOCUMENTATION MANAGEMENT \& IMPLEMENTATION PHASES](#technical-design-documentation-management--implementation-phases)
    - [BMAD METHOD FILES](#bmad-method-files)
  - [LEVERAGING IDE TASKS FOR EFFICIENCY](#leveraging-ide-tasks-for-efficiency)
    - [PURPOSE OF IDE TASKS](#purpose-of-ide-tasks)
    - [EXAMPLES OF TASK FUNCTIONALITY](#examples-of-task-functionality)

## BMAD METHOD - CORE PHILOSOPHY

**STATEMENT:** "Vibe CEO'ing" is about embracing the chaos, thinking like a CEO with unlimited resources and a singular vision, and leveraging AI as your high-powered team to achieve ambitious goals rapidly. The BMAD Method (Breakthrough Method of Agile (ai-driven) Development), with the integrated "Bmad Agent", elevates "vibe coding" to advanced project planning, providing a structured yet flexible framework to plan, execute, and manage software projects using a team of specialized AI agents.

**DETAILS:**

- Focus on ambitious goals and rapid iteration.
- Utilize AI as a force multiplier.
- Adapt and overcome obstacles with a proactive mindset.

## BMAD METHOD - AGILE METHODOLOGIES OVERVIEW

### CORE PRINCIPLES OF AGILE

- Individuals and interactions over processes and tools.
- Working software over comprehensive documentation.
- Customer collaboration over contract negotiation.
- Responding to change over following a plan.

### KEY PRACTICES IN AGILE

- Iterative Development: Building in short cycles (sprints).
- Incremental Delivery: Releasing functional pieces of the product.
- Daily Stand-ups: Short team meetings for synchronization.
- Retrospectives: Regular reviews to improve processes.
- Continuous Feedback: Ongoing input from stakeholders.

### BENEFITS OF AGILE

- Increased Flexibility: Ability to adapt to changing requirements.
- Faster Time to Market: Quicker delivery of valuable features.
- Improved Quality: Continuous testing and feedback loops.
- Enhanced Stakeholder Engagement: Close collaboration with users/clients.
- Higher Team Morale: Empowered and self-organizing teams.

## BMAD METHOD - ANALOGIES WITH AGILE PRINCIPLES

The BMAD Method, while distinct in its "Vibe CEO'ing" approach with AI, shares foundational parallels with Agile methodologies:

- **Individuals and Interactions over Processes and Tools (Agile) vs. Vibe CEO & AI Team (BMAD):**

  - **Agile:** Emphasizes the importance of skilled individuals and effective communication.
  - **BMAD:** The "Vibe CEO" (you) actively directs and interacts with AI agents, treating them as a high-powered team. The quality of this interaction and clear instruction ("CLEAR_INSTRUCTIONS", "KNOW_YOUR_AGENTS") is paramount, echoing Agile's focus on human elements.

- **Working Software over Comprehensive Documentation (Agile) vs. Rapid Iteration & Quality Outputs (BMAD):**

  - **Agile:** Prioritizes delivering functional software quickly.
  - **BMAD:** Stresses "START_SMALL_SCALE_FAST" and "ITERATIVE_REFINEMENT." While "DOCUMENTATION_IS_KEY" for good inputs (briefs, PRDs), the goal is to leverage AI for rapid generation of working components or solutions. The focus is on achieving ambitious goals rapidly.

- **Customer Collaboration over Contract Negotiation (Agile) vs. Vibe CEO as Ultimate Arbiter (BMAD):**

  - **Agile:** Involves continuous feedback from the customer.
  - **BMAD:** The "Vibe CEO" acts as the primary stakeholder and quality control ("QUALITY_CONTROL," "STRATEGIC_OVERSIGHT"), constantly reviewing and refining AI outputs, much like a highly engaged customer.

- **Responding to Change over Following a Plan (Agile) vs. Embrace Chaos & Adapt (BMAD):**

  - **Agile:** Values adaptability and responsiveness to new requirements.
  - **BMAD:** Explicitly encourages to "EMBRACE_THE_CHAOS," "ADAPT & EXPERIMENT," and acknowledges that "ITERATIVE_REFINEMENT" means it's "not a linear process." This directly mirrors Agile's flexibility.

- **Iterative Development & Incremental Delivery (Agile) vs. Story-based Implementation & Phased Value (BMAD):**

  - **Agile:** Work is broken down into sprints, delivering value incrementally.
  - **BMAD:** Projects are broken into Epics and Stories, with "Developer Agents" implementing stories one at a time. Epics represent "significant, deployable increments of value," aligning with incremental delivery.

- **Continuous Feedback & Retrospectives (Agile) vs. Iterative Refinement & Quality Control (BMAD):**
  - **Agile:** Teams regularly reflect and adjust processes.
  - **BMAD:** The "Vibe CEO" continuously reviews outputs ("QUALITY_CONTROL") and directs "ITERATIVE_REFINEMENT," serving a similar function to feedback loops and process improvement.

## BMAD METHOD - TOOLING AND RESOURCE LOCATIONS

Effective use of the BMAD Method relies on understanding where key tools, configurations, and informational resources are located and how they are used. The method is designed to be tool-agnostic in principle, with agent instructions and workflows adaptable to various AI platforms and IDEs.

- **BMAD Knowledge Base:** This document (`bmad-agent/data/bmad-kb.md`) serves as the central repository for understanding the BMAD method, its principles, agent roles, and workflows.
- **Orchestrator Agents:** A key feature is the Orchestrator agent (AKA "BMAD"), a master agent capable of embodying any specialized agent role.
  - **Web Agent Orchestrator:**
    - **Setup:** Utilizes a Node.js build script (`build-web-agent.js`) configured by `build-web-agent.cfg.js`.
    - **Process:** Consolidates assets (personas, tasks, templates, checklists, data) from an `/bmad-agent` into a `build_dir`, default: `/build/`.
    - **Output:** Produces bundled asset files (e.g., `personas.txt`, `tasks.txt`), an `agent-prompt.txt` (from `orchestrator_agent_prompt`), and an `agent-config.txt` (from `agent_cfg` like `web-bmad-orchestrator-agent.cfg.md`).
    - **Usage:** The `agent-prompt.txt` is used for the main custom web agent instruction set (e.g., Gemini 2.5 Gem or OpenAI Custom GPT), and the other build files are attached as knowledge/files.
  - **IDE Agent Orchestrator (`ide-bmad-orchestrator.md`):**
    - **Setup:** Works without a build step, dynamically loading its configuration.
    - **Configuration (`ide-bmad-orchestrator.cfg.md`):** Contains a `Data Resolution` section (defining base paths for assets like personas, tasks) and `Agent Definitions` (Title, Name, Customize, Persona file, Tasks).
    - **Operation:** Loads its config, lists available personas, and upon user request, embodies the chosen agent by loading its persona file and applying customizations.
    - The `ide-bmad-orchestrator` file contents can be used as the instructions for a custom agent mode. The agent supports a `/help` command that can help guide the user. The agent relies on the existence in the bmad-agent folder being at the root of the project.
    - The `ide-bmad-orchestrator` is not recommended for generating stories or doing development. While it CAN become those agents, its HIGHLY recommended to instead use the dedicated dev.ide.md or sm.ide.md as individual dedicated agents. The will use up less context overhead and are going to be used the most frequently.
- **Standalone IDE Agents:**
  - Optimized for IDE environments (e.g., Windsurf, Cursor), often under 6K characters (e.g., `dev.ide.md`, `sm.ide.md`).
  - Can directly reference and execute tasks.
- **Agent Configuration Files:**
  - `web-bmad-orchestrator-agent.cfg.md`: Defines agents the Web Orchestrator can embody, including references to personas, tasks, checklists, and templates (e.g., `personas#pm`, `tasks#create-prd`).
  - `ide-bmad-orchestrator.cfg.md`: Configures the IDE Orchestrator, defining `Data Resolution` paths (e.g., `(project-root)/bmad-agent/personas`) and agent definitions with persona file names (e.g., `analyst.md`) and task file names (e.g., `create-prd.md`).
  - `web-bmad-orchestrator-agent.md`: Main prompt for the Web Orchestrator.
  - `ide-bmad-orchestrator.md`: Main prompt/definition of the IDE Orchestrator agent.
- **Task Files:**
  - Located in `bmad-agent/tasks/` (and sometimes `bmad-agent/checklists/` for checklist-like tasks).
  - Self-contained instruction sets for specific jobs (e.g., `create-prd.md`, `checklist-run-task.md`).
  - Reduce agent bloat and provide on-demand functionality for any capable agent.
- **Core Agent Definitions (Personas):**
  - Files (typically `.md`) defining core personalities and instructions for different agents.
  - Located in `bmad-agent/personas/` (e.g., `analyst.md`, `pm.md`).
- **Project Documentation (Outputs):**
- **Project Briefs:** Generated by the Analyst agent.
- **Product Requirements Documents (PRDs):** Produced by the PM agent, containing epics and stories.
- **UX/UI Specifications & Architecture Documents:** Created by Design Architect and Architect agents.
- The **POSM agent** is crucial for organizing and managing these documents.
- **Templates:** Standardized formats for briefs, PRDs, checklists, etc., likely stored in `bmad-agent/templates/`.
- **Data Directory (`bmad-agent/data/`):** Stores persistent data, knowledge bases (like this one), and other key information for the agents.

## BMAD METHOD - COMMUNITY AND CONTRIBUTIONS

The BMAD Method thrives on community involvement and collaborative improvement.

- **Getting Involved:**
  - **GitHub Discussions:** The primary platform for discussing potential ideas, use cases, additions, and enhancements to the method.
  - **Reporting Bugs:** If you find a bug, check existing issues first. If unreported, provide detailed steps to reproduce, along with any relevant logs or screenshots.
  - **Suggesting Features:** Check existing issues and discussions. Explain your feature idea in detail and its potential value.
- **Contribution Process (Pull Requests):**
  1. Fork the repository.
  2. Create a new branch for your feature or bugfix (e.g., `feature/your-feature-name`).
  3. Make your changes, adhering to existing code style and conventions. Write clear comments for complex logic.
  4. Run any tests or linting to ensure quality.
  5. Commit your changes with clear, descriptive messages (refer to the project's commit message convention, often found in `docs/commit.md`).
  6. Push your branch to your fork.
  7. Open a Pull Request against the main branch of the original repository.
- **Code of Conduct:** All participants are expected to abide by the project's Code of Conduct.
- **Licensing of Contributions:** By contributing, you agree that your contributions will be licensed under the same license as the project (MIT License).

### Licensing

The BMAD Method and its associated documentation and software are distributed under the **MIT License**.

Copyright (c) 2025 Brian AKA BMad AKA Bmad Code

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

## BMAD METHOD - ETHOS & BEST PRACTICES

- **CORE_ETHOS:** You are the "Vibe CEO." Think like a CEO with unlimited resources and a singular vision. Your AI agents are your high-powered team. Your job is to direct, refine, and ensure quality towards your ambitious goal. The method elevates "vibe coding" to advanced project planning.
- **MAXIMIZE_AI_LEVERAGE:** Push the AI. Ask for more. Challenge its outputs. Iterate.
- **QUALITY_CONTROL:** You are the ultimate arbiter of quality. Review all outputs.
- **STRATEGIC_OVERSIGHT:** Maintain the high-level vision. Ensure agent outputs align.
- **ITERATIVE_REFINEMENT:** Expect to revisit steps. This is not a linear process.
- **CLEAR_INSTRUCTIONS:** The more precise your requests, the better the AI's output.
- **DOCUMENTATION_IS_KEY:** Good inputs (briefs, PRDs) lead to good outputs. The POSM agent is crucial for organizing this.
- **KNOW_YOUR_AGENTS:** Understand each agent's role (see [AGENT ROLES AND RESPONSIBILITIES](#agent-roles-and-responsibilities) or below). This includes understanding the capabilities of the Orchestrator agent if you are using one.
- **START_SMALL_SCALE_FAST:** Test concepts, then expand.
- **EMBRACE_THE_CHAOS:** Pioneering new methods is messy. Adapt and overcome.
- **ADAPT & EXPERIMENT:** The BMAD Method provides a structure, but feel free to adapt its principles, agent order, or templates to fit your specific project needs and working style. Experiment to find what works best for you. **Define agile the BMad way - or your way!** The agent configurations allow for customization of roles and responsibilities.

## AGENT ROLES AND RESPONSIBILITIES

Understanding the distinct roles and responsibilities of each agent is key to effectively navigating the BMAD workflow. While the "Vibe CEO" provides overall direction, each agent specializes in different aspects of the project lifecycle. V3 introduces Orchestrator agents that can embody these roles, with configurations specified in `web-bmad-orchestrator-agent.cfg.md` for web and `ide-bmad-orchestrator.cfg.md` for IDE environments.

- **Orchestrator Agent (BMAD):**

  - **Function:** The primary orchestrator, initially "BMAD." It can embody various specialized agent personas. It handles general BMAD queries, provides oversight, and is the go-to when unsure which specialist is needed.
  - **Persona Reference:** `personas#bmad` (Web) or implicitly the core of `ide-bmad-orchestrator.md` (IDE).
  - **Key Data/Knowledge:** Accesses `data#bmad-kb-data` (Web) for its knowledge base.
  - **Types:**
    - **Web Orchestrator:** Built using a script, leverages large context windows of platforms like Gemini 2.5 or OpenAI GPTs. Uses bundled assets. Its behavior and available agents are defined in `web-bmad-orchestrator-agent.cfg.md`.
    - **IDE Orchestrator:** Operates directly in IDEs like Cursor or Windsurf without a build step, loading persona and task files dynamically based on its configuration (`ide-bmad-orchestrator.cfg.md`). The orchestrator itself is defined in `ide-bmad-orchestrator.md`.
  - **Key Feature:** Simplifies agent management, especially in environments with limitations on the number of custom agents.

- **Analyst:**

  - **Function:** Handles research, requirements gathering, brainstorming, and the creation of Project Briefs.
  - **Web Persona:** `Analyst (Mary)` with persona `personas#analyst`. Customized to be "a bit of a know-it-all, and likes to verbalize and emote." Uses `templates#project-brief-tmpl`.
  - **IDE Persona:** `Analyst (Larry)` with persona `analyst.md`. Similar "know-it-all" customization. Tasks for Brainstorming, Deep Research Prompt Generation, and Project Brief creation are often defined within the `analyst.md` persona itself ("In Analyst Memory Already").
  - **Output:** `Project Brief`.

- **Product Manager (PM):**

  - **Function:** Responsible for creating and maintaining Product Requirements Documents (PRDs), overall project planning, and ideation related to the product.
  - **Web Persona:** `Product Manager (John)` with persona `personas#pm`. Utilizes `checklists#pm-checklist` and `checklists#change-checklist`. Employs `templates#prd-tmpl`. Key tasks include `tasks#create-prd`, `tasks#correct-course`, and `tasks#create-deep-research-prompt`.
  - **IDE Persona:** `Product Manager (PM) (Jack)` with persona `pm.md`. Focused on producing/maintaining the PRD (`create-prd.md` task) and product ideation/planning.
  - **Output:** `Product Requirements Document (PRD)`.

- **Architect:**

  - **Function:** Designs system architecture, handles technical design, and ensures technical feasibility.
  - **Web Persona:** `Architect (Fred)` with persona `personas#architect`. Uses `checklists#architect-checklist` and `templates#architecture-tmpl`. Tasks include `tasks#create-architecture` and `tasks#create-deep-research-prompt`.
  - **IDE Persona:** `Architect (Mo)` with persona `architect.md`. Customized to be "Cold, Calculating, Brains behind the agent crew." Generates architecture (`create-architecture.md` task), helps plan stories (`create-next-story-task.md`), and can update PO-level epics/stories (`doc-sharding-task.md`).
  - **Output:** `Architecture Document`.

- **Design Architect:**

  - **Function:** Focuses on UI/UX specifications, front-end technical architecture, and can generate prompts for AI UI generation services.
  - **Web Persona:** `Design Architect (Jane)` with persona `personas#design-architect`. Uses `checklists#frontend-architecture-checklist`, `templates#front-end-architecture-tmpl` (for FE architecture), and `templates#front-end-spec-tmpl` (for UX/UI Spec). Tasks: `tasks#create-frontend-architecture`, `tasks#create-ai-frontend-prompt`, `tasks#create-uxui-spec`.
  - **IDE Persona:** `Design Architect (Millie)` with persona `design-architect.md`. Customized to be "Fun and carefree, but a frontend design master." Helps design web apps, produces UI generation prompts (`create-ai-frontend-prompt.md` task), plans FE architecture (`create-frontend-architecture.md` task), and creates UX/UI specs (`create-uxui-spec.md` task).
  - **Output:** `UX/UI Specification`, `Front-end Architecture Plan`, AI UI generation prompts.

- **Product Owner (PO):**

  - **Function:** Agile Product Owner responsible for validating documents, ensuring development sequencing, managing the product backlog, running master checklists, handling mid-sprint re-planning, and drafting user stories.
  - **Web Persona:** `PO (Sarah)` with persona `personas#po`. Uses `checklists#po-master-checklist`, `checklists#story-draft-checklist`, `checklists#change-checklist`, and `templates#story-tmpl`. Tasks include `tasks#story-draft-task`, `tasks#doc-sharding-task` (extracts epics and shards architecture), and `tasks#correct-course`.
  - **IDE Persona:** `Product Owner AKA PO (Curly)` with persona `po.md`. Described as a "Jack of many trades." Tasks include `create-prd.md`, `create-next-story-task.md`, `doc-sharding-task.md`, and `correct-course.md`.
  - **Output:** User Stories, managed PRD/Backlog.

- **Scrum Master (SM):**

  - **Function:** A technical role focused on helping the team run the Scrum process, facilitating development, and often involved in story generation and refinement.
  - **Web Persona:** `SM (Bob)` with persona `personas#sm`. Described as "A very Technical Scrum Master." Uses `checklists#change-checklist`, `checklists#story-dod-checklist`, `checklists#story-draft-checklist`, and `templates#story-tmpl`. Tasks: `tasks#checklist-run-task`, `tasks#correct-course`, `tasks#story-draft-task`.
  - **IDE Persona:** `Scrum Master: SM (SallySM)` with persona `sm.ide.md`. Described as "Super Technical and Detail Oriented," specialized in "Next Story Generation" (likely leveraging the `sm.ide.md` persona's capabilities).

- **Developer Agents (DEV):**
  - **Function:** Implement user stories one at a time. Can be generic or specialized.
  - **Web Persona:** `DEV (Dana)` with persona `personas#dev`. Described as "A very Technical Senior Software Developer."
  - **IDE Personas:** Multiple configurations can exist, using the `dev.ide.md` persona file (optimized for <6K characters for IDEs). Examples:
    - `Frontend Dev (DevFE)`: Specialized in NextJS, React, Typescript, HTML, Tailwind.
    - `Dev (Dev)`: Master Generalist Expert Senior Full Stack Developer.
  - **Configuration:** Specialized agents can be configured in `ide-bmad-orchestrator.cfg.md` for the IDE Orchestrator, or defined for the Web Orchestrator. Standalone IDE developer agents (e.g., `dev.ide.md`) are also available.
  - **When to Use:** During the implementation phase, typically working within an IDE.

## NAVIGATING THE BMAD WORKFLOW - INITIAL GUIDANCE

### STARTING YOUR PROJECT - ANALYST OR PM?

- Use Analyst if unsure about idea/market/feasibility or need deep exploration.
- Use PM if concept is clear or you have a Project Brief.
- Refer to [AGENT ROLES AND RESPONSIBILITIES](#agent-roles-and-responsibilities) (or section within this KB) for full details on Analyst and PM.

### UNDERSTANDING EPICS - SINGLE OR MULTIPLE?

- Epics represent significant, deployable increments of value.
- Multiple Epics are common for non-trivial projects or a new MVP (distinct functional areas, user journeys, phased rollout).
- Single Epic might suit very small MVPs, or post MVP / brownfield new features.
- The PM helps define and structure epics.

## GETTING STARTED WITH BMAD

This section provides guidance for new users on how to set up their project with the BMAD agent structure and manage artifacts.

### Initial Project Setup

To begin using the BMAD method and its associated agents in your project, you need to integrate the core agent files:

- **Copy `bmad-agent` Folder:** The entire `bmad-agent` folder should be copied into the root directory of your project. This folder contains all the necessary personas, tasks, templates, and configuration files for the BMAD agents to function correctly.

### Exporting Artifacts from AI Platforms

Once an AI agent (like those in Gemini or ChatGPT) has generated a document (e.g., Project Brief, PRD, Architecture Document), you'll need to save it into your project:

- **Gemini:**
  - After the document is produced, click the `...` (more options) menu typically found near the response.
  - Select "Copy". The content will be copied as Markdown.
  - Paste this content into a new `.md` file within your project's `docs` folder (or a similar designated location).
  - **Passing to a new chat instance:** Gemini's chat interface may not directly support pasting Markdown with full fidelity in all scenarios.
    - You can paste the raw Markdown content directly.
    - Alternatively, save the content as a `.txt` file and paste from there.
    - For sharing or preserving formatting in Google Docs: Create a new Google Doc, right-click, and select "Paste without formatting" if pasting directly, or look for options to import/paste Markdown. Some browser extensions can facilitate Markdown rendering in Google Docs.
- **ChatGPT:**
  - ChatGPT generally handles Markdown well. You can copy the generated Markdown output directly.
  - Paste it into a `.md` file in your project's `docs` folder.
  - Sharing `.md` files or their content with new ChatGPT instances (e.g., by uploading the file or pasting the text) is typically straightforward.

### Document Sharding

Large documents like PRDs or Architecture Documents can become unwieldy for AI agents to process efficiently, especially in environments with context window limitations. The `doc-sharding-task.md` is designed to break these down:

- **Purpose:** The sharding task splits a large document (e.g., PRD, Architecture, Front-End Architecture) into smaller, more granular sections or individual user stories. This makes it easier for subsequent agents, like the SM (Scrum Master) or Dev Agents, to work with specific parts of the document without needing to process the entire thing.
- **How to Use:**
  1.  Ensure the large document you want to shard (e.g., `prd.md`, `architecture.md`) exists in your project's `docs` folder.
  2.  Instruct your active IDE agent (e.g., PO, SM, or the BMAD Orchestrator embodying one of these roles) to run the `doc-sharding-task.md`.
  3.  You will typically specify the _source file_ to be sharded. For example: "Run the `doc-sharding-task.md` against `docs/prd.md`."
  4.  The task will guide the agent to break down the document. The output might be new smaller files or instructions on how the document is logically segmented.

### Utilizing Dedicated IDE Agents (SM and Dev)

While the BMAD IDE Orchestrator can embody any persona, for common and intensive tasks like story generation (SM) and code implementation (Dev), it's highly recommended to use dedicated, specialized agents:

- **Why Dedicated Agents?**
  - **Context Efficiency:** Dedicated agents (e.g., `sm.ide.md`, `dev.ide.md`) are leaner as their persona files are smaller and more focused. This is crucial in IDEs where context window limits can impact performance and output quality.
  - **Performance:** Less overhead means faster responses and more focused interactions.
- **Recommendation:**
  - Favor using `sm.ide.md` for Scrum Master tasks (like generating the next story).
  - Favor using `dev.ide.md` (or specialized versions like `dev-frontend.ide.md`) for development tasks.
- **Creating Your Own Dedicated Agents:**
  - If your IDE supports more than a few custom agent modes (unlike Cursor's typical limit of 5 without paying for more), you can easily create your own specialized agents.
  - Take the content of a base persona file (e.g., `bmad-agent/personas/architect.md`).
  - Optionally, integrate the content of frequently used task files directly into this new persona file.
  - Save this combined content as a new agent mode in your IDE (e.g., `my-architect.ide.md`). This approach mirrors how the `sm.ide.md` agent is structured.

### When to Use the BMAD IDE Orchestrator

The BMAD IDE Orchestrator (`ide-bmad-orchestrator.md` configured by `ide-bmad-orchestrator.cfg.md`) provides flexibility but might not always be the most efficient choice.

- **Useful Scenarios:**
  - **Cursor IDE with Agent Limits:** If you're using an IDE like Cursor and frequently need to switch between many different agent personalities (Analyst, PM, Architect, etc.) beyond the typical free limit for custom modes, the Orchestrator allows you to access all configured personas through a single agent slot.
  - **Unified Experience (Gemini/ChatGPT Parity):** If you prefer to interact with the BMAD agent system in your IDE in the same way you would in a web UI like Gemini (using the BMAD Orchestrator to call upon different specialists), and you are not concerned about context limits or potential costs associated with larger LLM models that can handle the Orchestrator's broader context.
  - **Access to all Personas:** You want quick access to any of the defined agent personas without setting them up as individual IDE modes.
- **Potentially Unnecessary / Less Optimal Scenarios:**
  - **Simple Projects / Feature Additions (Caution Advised):** For very simple projects or when adding a small feature to an existing codebase, you _might_ consider a streamlined flow using the Orchestrator to embody the PM, generate a PRD with epics/stories, and then directly move to development, potentially skipping detailed architecture.
    - In such cases, the PM persona might be prompted to ask more technical questions to ensure generated stories are sufficiently detailed for developers.
    - **This is generally NOT recommended** as it deviates from the robust BMAD process and is not yet a fully streamlined or validated path. It risks insufficient planning and lower quality outputs.
  - **Frequent SM/Dev Tasks:** As mentioned above, for regular story creation and development, dedicated SM and Dev agents are more efficient due to smaller context overhead.

Always consider the trade-offs between the Orchestrator's versatility and the efficiency of dedicated agents, especially concerning your IDE's capabilities and the complexity of your project.

## SUGGESTED ORDER OF AGENT ENGAGEMENT (TYPICAL FLOW)

**NOTE:** This is a general guideline. The BMAD method is iterative; phases/agents might be revisited.

1. **Analyst** - brainstorm and create a project brief.
2. **PM (Product Manager)** - use the brief to produce a PRD with high level epics and stories.
3. **Design Architect UX UI Spec for PRD (If project has a UI)** - create the front end UX/UI Specification.
4. **Architect** - create the architecture and ensure we can meet the prd requirements technically - with enough specification that the dev agents will work consistently.
5. **Design Architect (If project has a UI)** - create the front end architecture and ensure we can meet the prd requirements technically - with enough specification that the dev agents will work consistently.
6. **Design Architect (If project has a UI)** - Optionally create a prompt to generate a UI from AI services such as Lovable or V0 from Vercel.
7. **PO**: Validate documents are aligned, sequencing makes sense, runs a final master checklist. The PO can also help midstream development replan or course correct if major changes occur.
8. **PO or SM**: Generate Stories 1 at a time (or multiple but not recommended) - this is generally done in the IDE after each story is completed by the Developer Agents.
9. **Developer Agents**: Implement Stories 1 at a time. You can craft different specialized Developer Agents, or use a generic developer agent. It is recommended to create specialized developer agents and configure them in the `ide-bmad-orchestrator.cfg`.

## HANDLING MAJOR CHANGES

Major changes are an inherent part of ambitious projects. The BMAD Method embraces this through its iterative nature and specific agent roles:

- **Iterative by Design:** The entire BMAD workflow is built on "ITERATIVE_REFINEMENT." Expect to revisit previous steps and agents as new information emerges or requirements evolve. It's "not a linear process."
- **Embrace and Adapt:** The core ethos includes "EMBRACE_THE_CHAOS" and "ADAPT & EXPERIMENT." Major changes are opportunities to refine the vision and approach.
- **PO's Role in Re-planning:** The **Product Owner (PO)** is key in managing the impact of significant changes. They can "help midstream development replan or course correct if major changes occur." This involves reassessing priorities, adjusting the backlog, and ensuring alignment with the overall project goals.
- **Strategic Oversight by Vibe CEO:** As the "Vibe CEO," your role is to maintain "STRATEGIC_OVERSIGHT." When major changes arise, you guide the necessary pivots, ensuring the project remains aligned with your singular vision.
- **Re-engage Agents as Needed:** Don't hesitate to re-engage earlier-phase agents (e.g., Analyst for re-evaluating market fit, PM for revising PRDs, Architect for assessing technical impact) if a change significantly alters the project's scope or foundations.

## IDE VS UI USAGE - GENERAL RECOMMENDATIONS

The BMAD method can be orchestrated through different interfaces, typically a web UI for higher-level planning and an IDE for development and detailed developer story generation. The most general recommendation is to do all document generation from the brief, PRD, Architecture, Design Architecture, and potentially UI Prompts. Also use the PO to run the full final checklist to ensure all documents are aligned with various changes. For example, did the architect discover something that requires an update to a epic or story sequence in the PRD? The PO will help you there. Once done, then export the documents to the IDE. If documents have been modified, you can ask the specific proper agents in Gemini or chatGPT to give you the final unredacted complete document. Save these into the docs folder of your project.

### CONCEPTUAL, PLANNING PHASES and TECHNICAL DESIGN

- **Interface:** Often best managed via a Web UI (leveraging the **Web Agent Orchestrator** with its bundled assets and `agent-prompt.txt`) or dedicated project management tools where orchestrator agents can guide the process.
- **Agents Involved:**
  - **Analyst:** Brainstorming, research, and initial project brief creation.
  - **PM (Product Manager):** PRD development, epic and high-level story definition.
  - **Architect / Design Architect (UI):** Detailed technical design and specification.
  - **PO:** Checklist runner to make sure all of the documents are aligned.
- **Activities:** Defining the vision, initial requirements gathering, market analysis, high-level planning. The `web-bmad-orchestrator-agent.md` and its configuration likely support these activities.

### DOCUMENTATION MANAGEMENT & IMPLEMENTATION PHASES

- **Interface:** Primarily within the Integrated Development Environment (IDE), leveraging specialized agents (standalone or via the **IDE Agent Orchestrator** configured with `ide-bmad-orchestrator.cfg.md`).
- **Agents Involved:**
  - "**PO or SM or BMad Agent:** Run the doc sharing task to split the large files that have been created (PRD, Architecture etc...) into smaller granular documents that are easier for the SM and Dev Agents to work with.
  - **SM (Scrum Master):** Detailed story generation, backlog refinement, often directly in the IDE or tools integrated with it.
  - **Developer Agents:** Code implementation for stories, working directly with the codebase in the IDE.
- **Activities:** Detailed architecture, front-end/back-end design, code development, testing, leveraging IDE tasks (see "LEVERAGING IDE TASKS FOR EFFICIENCY"), using configurations like `ide-bmad-orchestrator.cfg.md`.

### BMAD METHOD FILES

Understanding key files helps in navigating and customizing the BMAD process:

- **Knowledge & Configuration:**
  - `bmad-agent/data/bmad-kb.md`: This central knowledge base.
  - `ide-bmad-orchestrator.cfg.md`: Configuration for IDE developer agents.
  - `ide-bmad-orchestrator.md`: Definition of the IDE orchestrator agent.
  - `web-bmad-orchestrator-agent.cfg.md`: Configuration for the web orchestrator agent.
  - `web-bmad-orchestrator-agent.md`: Definition of the web orchestrator agent.
- **Task Definitions:**
  - Files in `bmad-agent/tasks/` or `bmad-agent/checklists/` (e.g., `checklist-run-task.md`): Reusable prompts for specific actions and also used by agents to keep agent persona files lean.
- **Agent Personas & Templates:**
  - Files in `bmad-agent/personas/`: Define the core behaviors of different agents.
  - Files in `bmad-agent/templates/`: Standard formats for documents like Project Briefs, PRDs that the agents will use to populate instances of these documents.
- **Project Artifacts (Outputs - locations vary based on project setup):**
  - Project Briefs
  - Product Requirements Documents (PRDs)
  - UX/UI Specifications
  - Architecture Documents
  - Codebase and related development files.

## LEVERAGING IDE TASKS FOR EFFICIENCY

### PURPOSE OF IDE TASKS

- **Reduce Agent Bloat:** Avoid adding numerous, rarely used instructions to primary IDE agent modes (Dev Agent, SM Agent) or even the Orchestrator's base prompt. Keeps agents lean, beneficial for IDEs with limits on custom agent complexity/numbers.
- **On-Demand Functionality:** Instruct an active IDE agent (standalone or an embodied persona within the IDE Orchestrator) to perform a task by providing the content of the relevant task file (e.g., from `bmad-agent/tasks/checklist-run-task.md`) as a prompt, or by referencing it if the agent is configured to find it (as with the IDE Orchestrator).
- **Versatility:** Any sufficiently capable agent can be asked to execute a task. Tasks can handle specific functions like running checklists, creating stories, sharding documents, indexing libraries, etc. They are self-contained instruction sets.

### EXAMPLES OF TASK FUNCTIONALITY

**CONCEPT:** Think of tasks as specialized, callable mini-agents or on-demand instruction sets that main IDE agents or the Orchestrator (when embodying a persona) can invoke, keeping primary agent definitions streamlined. They are particularly useful for operations not performed frequently. The `docs/instruction.md` file provides more details on task setup and usage.

Here are some examples of functionalities provided by tasks found in `bmad-agent/tasks/`:

- **`create-prd.md`:** Guides the generation of a Product Requirements Document.
- **`create-next-story-task.md`:** Helps in defining and creating the next user story for development.
- **`create-architecture.md`:** Assists in outlining the technical architecture for a project.
- **`create-frontend-architecture.md`:** Focuses specifically on designing the front-end architecture.
- **`create-uxui-spec.md`:** Facilitates the creation of a UX/UI Specification document.
- **`create-ai-frontend-prompt.md`:** Helps in drafting a prompt for an AI service to generate UI/frontend elements.
- **`doc-sharding-task.md`:** Provides a process for breaking down large documents into smaller, manageable parts.
- **`library-indexing-task.md`:** Assists in creating an index or overview of a code library.
- **`checklist-run-task.md`:** Executes a predefined checklist (likely using `checklist-mappings.yml`).
- **`correct-course.md`:** Provides guidance or steps for when a project needs to adjust its direction.
- **`create-deep-research-prompt.md`:** Helps formulate prompts for conducting in-depth research on a topic.

These tasks allow agents to perform complex, multi-step operations by following the detailed instructions within each task file, often leveraging templates and checklists as needed.

==================== END: bmad-kb ====================


==================== START: technical-preferences ====================
# User-Defined Preferred Patterns and Preferences

See example files in this folder.
list out your technical preferences, patterns you like to follow, language framework or starter project preferences. 

Anything you learn or prefer over time to drive future project choices, add the here.

==================== END: technical-preferences ====================
==================== START: odoo-best-practices ====================
# Odoo Development Best Practices

## 1. ORM Usage
- **Batch Operations:** Always use ORM methods (`create`, `write`, `unlink`, `search`, `browse`) on recordsets (multiple records) for performance, instead of iterating and calling them one by one.
- **Context:** Understand and utilize the `context` dictionary for specific behaviors (e.g., `with_context`, `sudo`).
- **`ensure_one()`:** Use `self.ensure_one()` when a method should only operate on a single record.
- **Computed Fields:**
    - Use `store=True` judiciously; it's useful for performance on frequently searched/grouped fields but adds write overhead.
    - Ensure `depends` decorator lists all relevant fields for computation.
- **Avoid Raw SQL:** Prefer Odoo's ORM methods unless absolutely necessary for complex queries not efficiently handled by ORM. If using raw SQL, use `self.env.cr.execute()` and parameterize your queries to prevent SQL injection.

## 2. Security
- **Access Rights (`ir.model.access.csv`):** Define read, write, create, unlink permissions for all custom models and relevant groups.
- **Record Rules (`ir.rule`):** Implement row-level security for multi-company, multi-user, or data segregation needs.
- **Groups:** Assign access rights to specific user groups, not individual users.
- **`sudo()` / `sudo(False)`:** Use `sudo()` sparingly and explicitly. `sudo()` elevates privileges; `sudo(False)` drops them back to the current user's. Be mindful of security implications.

## 3. Views
- **XML IDs:** Use consistent and descriptive XML IDs (e.g., `module_name.view_model_form`).
- **Inheritance:**
    - **`inherit_id`:** Use for extending existing Odoo views.
    - **`xpath`:** Use `xpath` with `position="after"`, `before`, `replace`, `attributes`, `inside` to precisely modify views.
    - **`priority`:** If multiple modules inherit the same view, `priority` can determine which inheritance applies last.
- **`tree` and `form` views:** Always provide these for any custom model.
- **`search` view:** Always provide a search view for ease of filtering.
- **`chatter`:** Include `mail_thread` and `mail_followers` widgets for communication features.

## 4. Performance
- **`_rec_name`:** Set `_rec_name` on models if the display field is not `name`.
- **Indexing:** Use `index=True` on fields that are frequently searched or used in `group by` clauses.
- **Lazy Loading:** Odoo's ORM loads records lazily. Be aware of this and avoid fetching unnecessary data.
- **Scheduled Actions (Cron):** For long-running or batch processes, use `ir.cron` instead of synchronous operations.
- **Computed Field `store=False` vs `store=True`:** `store=False` computes on the fly (can be slow if many records/complex computation); `store=True` stores in DB (faster read, slower write). Choose based on access patterns.

## 5. Code Quality
- **PEP8:** Follow Python's PEP8 style guide.
- **Odoo Coding Guidelines:** Adhere to Odoo's specific coding conventions.
- **`_logger`:** Use `logging.getLogger(__name__)` for proper logging within your module.
- **Docstrings:** Write clear docstrings for models, methods, and classes.
- **Translatable Strings:** Wrap all user-facing strings with `_()` for internationalization.

## 6. Testing
- **Unit Tests:** Write tests for your custom models and methods to ensure correctness and prevent regressions.
- **`odoo.tests.common.TransactionCase`:** Most common test class, rolls back changes after each test.
- **Test Tags:** Use `@tagged()` decorator for better test organization and selective execution.

## 7. Configuration & Deployment
- **`__manifest__.py`:** Keep it accurate and up-to-date with dependencies, data files, and module information.
- **Credentials:** Never hardcode sensitive credentials (API keys, passwords). Use `ir.config_parameter` or environment variables.
- **Auto-install:** Set `auto_install = False` for most custom modules to prevent accidental installation.

## 8. General
- **Inherit vs. Override:** Understand when to inherit models (`_inherit`, `_name`) vs. overriding methods (using `super()`).
- **Dependencies:** Declare all module dependencies in `__manifest__.py`.
- **Clear Commit Messages:** Write descriptive commit messages for version control.
==================== END: odoo-best-practices ====================

==================== START: odoo-orm-examples ====================
# Odoo ORM Examples

## 1. Creating Records
```python
# Create a single record
product_template = self.env['product.template'].create({
    'name': 'My New Product',
    'type': 'product',
    'list_price': 100.0,
})
# Create multiple records (list of dictionaries)
products = self.env['product.template'].create([
    {'name': 'Product A', 'list_price': 50.0},
    {'name': 'Product B', 'list_price': 75.0},
])
## 2. Searching Records
```python
# Search all active partners
active_partners = self.env['res.partner'].search([('active', '=', True)])
# Search partners with specific name and city
specific_partners = self.env['res.partner'].search([
    ('name', 'ilike', 'Odoo'),
    ('city', '=', 'Brussels')
])
# Search with complex domain (AND is implicit, OR needs '|', NOT needs '!')
complex_search = self.env['sale.order'].search([
    '|', # OR condition for the next two domains
        ('state', '=', 'draft'),
        ('state', '=', 'sent'),
    ('amount_total', '>', 500),
    '!', ('partner_id.country_id.code', '=', 'US') # NOT a US partner
])
# Limit and order results
ten_products = self.env['product.product'].search([], limit=10, order='name desc')
## 3. Browse Records (Accessing Fields)
```python
# Accessing a field value
product_name = product_template.name # 'My New Product'
# Accessing a Many2one field's recordset
partner_country = specific_partners.partner_id.country_id.name
# Iterating over a recordset
for product in products:
    print(f"Product: {product.name}, Price: {product.list_price}")
## 4. Updating Records
```python
# Update a single record
product_template.write({'list_price': 120.0})
# Update multiple records in a recordset
products_to_update = self.env['product.template'].search([('list_price', '<', 100)])
products_to_update.write({'active': False}) # Deactivate all products under 100
## 5. Deleting Records
```python
# Delete a single record
product_template.unlink()
# Delete multiple records
products_to_delete = self.env['product.template'].search([('name', 'like', 'Temp Product')])
products_to_delete.unlink()
## 6. Accessing Environment and Current User
```python
# Current user
current_user = self.env.user
# Current company
current_company = self.env.company
# Accessing another model's recordset
res_partner_model = self.env['res.partner']
# Switching user context
admin_partner = self.env['res.partner'].sudo().search([('name', '=', 'Administrator')], limit=1)
if admin_partner:
    # Perform an action as another user (e.g., admin)
    admin_partner.with_user(self.env.ref('base.user_admin')).write({'comment': 'Updated by specific user'})
# Switching company context
with self.env(company=self.env.ref('base.main_company')): # Assuming 'base.main_company' is an existing company
    main_company_users = self.env['res.users'].search([])
## 7. Calling Methods
```python
# Calling a method on a recordset
sale_order = self.env['sale.order'].browse(123)
sale_order.action_confirm()
# Calling a method with arguments
product_data = self.env['product.template'].browse(456)
product_data.do_some_calculation(value1=10, value2=20)
## 8. Relational Fields
```python
# Many2one: Accessing the related recordset
sale_order = self.env['sale.order'].browse(sale_order_id)
partner = sale_order.partner_id
partner_name = partner.name

# One2many: Accessing the related recordset (list of records)
sale_order_lines = sale_order.order_line
for line in sale_order_lines:
    print(f"Product: {line.product_id.name}, Quantity: {line.product_uom_qty}")

# Many2many: Accessing the related recordset
user_groups = self.env.user.groups_id
for group in user_groups:
    print(f"User belongs to group: {group.name}")

# Adding/Removing records from Many2many or One2many (special commands)
# (0, 0, {values})    link to a new record that will be created
# (1, ID, {values})   update an existing record
# (2, ID, False)      remove and delete
# (3, ID, False)      unlink (delete association but not the record)
# (4, ID, False)      link to existing
# (5, False, False)   unlink all
# (6, False, [IDs])   replace all with a new list
## 9. Exceptions and Logging
```python
from odoo.exceptions import ValidationError, UserError
import logging
_logger = logging.getLogger(__name__)

# User-friendly error
raise UserError("This action is not allowed.")
# Validation error (for constraints)
raise ValidationError("Field X must be unique.")

# Logging
_logger.info("A custom message: %s", my_variable)
_logger.warning("Something potentially problematic happened.")
_logger.error("An error occurred: %s", str(e))
_logger.debug("Debug information.")

==================== END: odoo-orm-examples ====================

==================== START: odoo-ai-model-types ====================

Odoo AI Model Types and Use Cases
This section outlines common AI model types and their potential applications within Odoo workflows.

1. Natural Language Processing (NLP)
Description: AI models that understand, interpret, and generate human language.
Odoo Use Cases:
Text Classification:
Categorizing incoming support tickets (e.g., "Technical Issue," "Billing," "Feature Request").
Classifying customer emails (e.g., "Inquiry," "Complaint," "Order Confirmation").
Tagging product descriptions based on attributes.
Sentiment Analysis:
Analyzing customer feedback (from chatter, emails) to gauge satisfaction.
Assessing sentiment in social media mentions linked to Odoo records.
Text Summarization:
Summarizing long customer notes or contract terms in Odoo.
Generating brief internal summaries of external documents linked to opportunities.
Named Entity Recognition (NER):
Extracting key entities (e.g., company names, dates, product codes) from unstructured text in Odoo records.
Populating fields automatically from email content.
Chatbots/Virtual Assistants:
Providing automated responses to common customer queries through Odoo's website chat.
Internal Odoo user support.
2. Regression Models
Description: AI models used for predicting a continuous numerical output.
Odoo Use Cases:
Sales Forecasting: Predicting future sales volumes or revenue based on historical Odoo sales data.
Inventory Demand Prediction: Forecasting demand for products to optimize stock levels and reordering.
Lead Scoring: Predicting the likelihood of a lead converting to an opportunity (though often handled by classification as 'high/medium/low').
Delivery Time Prediction: Estimating delivery times for orders.
3. Classification Models
Description: AI models used for predicting a discrete categorical output (e.g., "yes/no," "A/B/C").
Odoo Use Cases:
Lead Scoring: Classifying leads as "Hot," "Warm," or "Cold" based on CRM data.
Fraud Detection: Identifying potentially fraudulent sales orders or payments.
Customer Churn Prediction: Predicting which customers are at risk of leaving.
Document Categorization: Automatically assigning documents (e.g., invoices, contracts) to specific Odoo document types.
Product Recommendation: Recommending products to customers based on their purchase history (can also be collaborative filtering).
4. Time Series Models
Description: Specialized models for forecasting data points in time series (data points ordered by time).
Odoo Use Cases:
Advanced Sales Forecasting: More granular and robust forecasting, considering seasonality, trends, and external factors.
Inventory Optimization: Predicting short-term stock needs with higher accuracy.
Resource Planning: Forecasting resource (e.g., manufacturing capacity, support agent) requirements.
5. Computer Vision (CV)
Description: AI models that enable computers to "see" and interpret visual information.
Odoo Use Cases (More Niche, but Growing):
Invoice/Document Processing: Extracting data from scanned invoices or receipts for automated entry into Odoo.
Product Recognition: Identifying products from images (e.g., for inventory auditing).
Quality Control: Detecting defects in manufactured goods by analyzing images.
Face Recognition: (Highly sensitive, use with extreme caution and clear privacy policies) for time tracking or access control.
6. Anomaly Detection Models
Description: AI models used to identify rare items, events, or observations that deviate significantly from the majority of the data.
Odoo Use Cases:
Fraud Detection: Flagging unusual financial transactions or employee expenses.
System Monitoring: Identifying unusual patterns in Odoo server logs or user activity indicating a security breach or performance issue.
Data Quality: Pinpointing data entry errors or inconsistencies that fall outside normal patterns.
Considerations for Odoo:

Data Availability: Odoo's rich dataset makes it a great source for training and inference.
Integration Complexity: Direct integration might involve custom Odoo modules using Python's requests for external APIs or odoo-ai specific libraries (if available).
Performance: For real-time AI, latency is crucial. For batch AI, consider scheduled actions (ir.cron) or background jobs (queue_job).
Cost: External AI services (like Google Cloud AI, Azure AI, OpenAI) incur costs based on usage. ==================== END: odoo-ai-model-types ====================
==================== START: odoo-ai-integration-patterns ====================
Odoo AI Integration Patterns
This section describes common architectural patterns for integrating AI functionalities with Odoo.

1. Direct API Integration (Synchronous)
Description: Odoo directly calls an external AI service's REST API and waits for an immediate response.
When to Use:
For real-time predictions or analysis where immediate results are needed (e.g., lead scoring on save, instant text analysis).
When AI tasks are relatively quick to process (low latency).
For smaller data volumes.
Pros: Simplicity, immediate feedback to the user.
Cons:
Blocking UI: Long-running AI tasks can freeze the Odoo user interface.
Scalability: Can hit API rate limits if many users trigger calls simultaneously.
Error Handling: Requires robust error handling for external service downtime or network issues.
Odoo Implementation: Python requests library within an Odoo model method, triggered by a button click, onchange, or create/write override.
2. Asynchronous Processing (Via Odoo queue_job or ir.cron)
Description: Odoo triggers an AI task in the background, allowing the user to continue working. Results are then processed when available.
When to Use:
For long-running AI tasks (e.g., batch processing of data, complex NLP analysis, image processing).
To avoid blocking the Odoo UI.
For large data volumes where real-time response isn't critical.
Pros: Improved user experience, better scalability, resilience to temporary AI service outages.
Cons: Results are not immediate; requires mechanisms to notify users when results are ready.
Odoo Implementation:
queue_job (Community module): Decorate methods with @job to run them in a separate process.
ir.cron (Scheduled Actions): For periodic batch AI processing (e.g., nightly analysis of all new leads).
_compute_job (Odoo Enterprise): A similar mechanism for background jobs.
Results stored in Odoo fields once available, possibly triggering an Odoo notification.
3. Webhook / Callback Integration
Description: Odoo makes an initial request to an AI service, which then notifies Odoo (via a webhook) once the processing is complete.
When to Use:
When the AI service itself offers webhook capabilities.
For processes that might take a significant amount of time and Odoo needs to be informed upon completion.
Pros: Efficient, AI service manages the long-running task, Odoo is only involved when needed.
Cons: Requires Odoo to be publicly accessible or have a secure tunnel for incoming webhooks; adds complexity for webhook security.
Odoo Implementation:
Odoo custom controller (http.Controller) to expose a public endpoint for the webhook.
Validate incoming webhook requests (signatures, IP whitelisting).
4. Message Queue Integration (e.g., RabbitMQ, Kafka)
Description: Odoo publishes messages to a message queue, an external worker (listening to the queue) picks up the message, interacts with the AI service, and then publishes results back to another queue, which Odoo consumes.
When to Use:
For highly scalable, decoupled architectures.
When integrating with multiple AI services or microservices.
For complex event-driven workflows.
Pros: Highly scalable, fault-tolerant, loose coupling between Odoo and AI service.
Cons: Adds significant architectural complexity, requires managing an external message queue system.
Odoo Implementation: Custom Odoo module using Python libraries for message queue interaction (e.g., pika for RabbitMQ). Requires external worker processes.
5. Embedded / On-Premise AI Models
Description: The AI model (or a lightweight version) runs directly within the Odoo server environment or on a co-located server.
When to Use:
For sensitive data that cannot leave the local network.
For high-frequency, low-latency predictions where external API calls are too slow.
When using open-source AI libraries (e.g., scikit-learn, spaCy) for simpler models.
Pros: Low latency, full control over data, no external API costs (except for infrastructure).
Cons: Resource-intensive (requires sufficient Odoo server resources), model updates/management can be more complex, limited to models that can run locally.
Odoo Implementation: Python code within Odoo models using AI libraries directly. Model files stored on the Odoo server.
Choosing a Pattern:
The best pattern depends on your specific use case, required latency, data volume, budget, and architectural preferences. Start with the simplest pattern that meets your needs and scale up if necessary.
==================== END: odoo-ai-integration-patterns ====================
==================== START: odoo-owl-concepts ====================
# Odoo OWL (Odoo Web Library) Concepts

OWL is a modern, component-based JavaScript framework developed by Odoo. It's designed to build highly interactive and reactive user interfaces within the Odoo web client, website, and Point of Sale (PoS).

## 1. Components
-   **Definition:** The fundamental building block of OWL applications. A component is a self-contained, reusable piece of UI that encapsulates its own logic and view.
-   **Structure:** Typically consists of a JavaScript class (extending `Component`) and an associated QWeb template (`static template = xml` or a separate XML file).
-   **Lifecycle:** Components have lifecycle hooks (`setup`, `onWillStart`, `onMounted`, `onWillUpdate`, `onWillDestroy`, `onRendered`, `onPatched`) that allow running code at specific points in their existence.

## 2. QWeb Templating
-   **Purpose:** OWL uses QWeb for declarative UI definition. QWeb is Odoo's powerful templating engine, allowing to mix HTML with Python-like directives.
-   **Directives:**
    -   `t-name`: Defines the name of a template.
    -   `t-if`/`t-elif`/`t-else`: Conditional rendering.
    -   `t-foreach`: Iterating over lists.
    -   `t-esc`: Escapes HTML characters (safe for displaying user input).
    -   `t-out`: Does not escape HTML (for displaying raw HTML).
    -   `t-att`, `t-attf`: Dynamic attribute setting.
    -   `t-on-*`: Event binding (e.g., `t-on-click`, `t-on-input`).
    -   `<t-component>`: Renders another OWL component.
-   **XML Files:** QWeb templates for OWL components are typically defined in `.xml` files within the `static/src/xml` directory and loaded via `web.assets_qweb` in `__manifest__.py`.

## 3. State Management (`useState`)
-   **`useState` Hook:** The primary mechanism for managing reactive local state within a component.
-   **Reactivity:** When a property on an object wrapped by `useState` is changed, OWL automatically re-renders the component and its children that depend on that state.
-   **Immutability:** While `useState` wraps the object, it's good practice to treat state updates carefully, sometimes creating new objects/arrays for complex changes to ensure reactivity.

## 4. Props (`static props`)
-   **Definition:** `props` are properties passed from a parent component to a child component. They are read-only for the child.
-   **Declaration:** Declared using `static props = { ... }` in the component class, specifying name, type, optionality, and default values.
-   **Unidirectional Data Flow:** Data flows down from parent to child via props. To communicate back, children emit events.

## 5. Hooks
-   **Definition:** Functions that "hook into" OWL's reactive system and component lifecycle. They can only be called inside the `setup()` method.
-   **Common Hooks:**
    -   `useState`: For local reactive state.
    -   `useRef`: For direct DOM element access.
    -   `useService`: For injecting and using Odoo's frontend services (e.g., `orm`, `notification`, `router`).
    -   `onMounted`: Runs code after the component is first rendered and inserted into the DOM.
    -   `onWillUpdate`/`onPatched`: Runs before/after a component's update.
    -   `onWillDestroy`: Runs before a component is removed from the DOM.

## 6. Services (`useService`, `registry`)
-   **Definition:** Global, singleton objects that provide common functionalities (e.g., making RPC calls, showing notifications, routing).
-   **Accessing:** Components access services using the `useService` hook (`this.env.services.service_name`).
-   **Registration:** Services are registered in Odoo's frontend `registry` (`@web/core/registry`).

## 7. Patching (Extending Core Components)
-   **`patch` function:** Used to modify or extend the behavior of existing OWL components or JavaScript classes provided by Odoo.
-   **Non-destructive:** `patch` is non-destructive; it extends functionality without directly altering the original class, making upgrades easier.
-   **Example:** Patching `FormController` to add custom logic to a form view.

## 8. Asset Bundling
-   **`__manifest__.py`:** OWL component JS and XML (QWeb) files must be included in an appropriate `assets` bundle in the Odoo module's `__manifest__.py` file (e.g., `web.assets_backend`, `web.assets_frontend`, `web.assets_qweb`).
-   **Order:** The order of files in `assets` bundles can be important for dependencies.
==================== END: odoo-owl-concepts ====================

==================== START: odoo-web-framework-guide ====================
# Odoo Web Framework Guide (Backend Client)

The Odoo Web framework is the foundation for the Odoo backend user interface. It is built on JavaScript, QWeb, and OWL (for newer Odoo versions).

## 1. Module Structure and Assets
-   **`static/src/js/`**: Contains JavaScript files for custom logic, widgets, and OWL components.
-   **`static/src/xml/`**: Contains QWeb templates (`.xml` files) used by JavaScript for rendering UI elements.
-   **`static/src/scss/`**: Contains SCSS (Sass) files for custom styling.
-   **`static/src/img/`**: For images used in the frontend.
-   **`__manifest__.py`**: Frontend files must be declared in the `assets` key to be loaded by Odoo.
    -   `web.assets_backend`: For assets specific to the backend (admin) interface.
    -   `web.assets_frontend`: For assets specific to the public website.
    -   `web.assets_qweb`: For QWeb templates loaded by the JS framework.
    -   Custom bundles can be created for modularity.

## 2. JavaScript Modules (`@odoo-module`, `registry`)
-   **`@odoo-module`:** The standard way to define an Odoo JavaScript module. Each `.js` file typically starts with `/** @odoo-module **/`.
-   **`registry`:** The central place in Odoo's frontend where various components, services, and extensions are registered.
    -   `registry.category("services")`: For global services (e.g., `orm`, `notification`).
    -   `registry.category("views")`: For custom view types (e.g., a custom Kanban view).
    -   `registry.category("fields")`: For custom field widgets (e.g., a custom color picker).
    -   `registry.category("actions")`: For custom actions handled by the `ActionManager`.
-   **Patching (`patch`):** The preferred way to extend or modify existing Odoo JavaScript components and classes without directly inheriting and duplicating code. This is crucial for maintainability and upgrade compatibility.

## 3. QWeb Templating (for JS)
-   QWeb templates (`.xml` files) are used by JavaScript components to render HTML.
-   They are loaded via `web.assets_qweb` in `__manifest__.py`.
-   They provide a powerful way to define dynamic HTML structures, including loops, conditionals, and event bindings.

## 4. Odoo RPC (Remote Procedure Calls)
-   The primary way for JavaScript in the frontend to communicate with the Python backend.
-   Performed via `this.env.services.rpc` or `this.orm.call()`.
-   Allows calling any Python method exposed as a `@api.model` or `@api.multi` method in Odoo models, or methods in `http.Controller` classes.

## 5. Extending Views (XML)
-   **Inheritance:** Odoo's XML views can be extended using `inherit_id` and `xpath`.
-   **`xpath`:** Allows precise insertion (`position="after"`, `before`, `inside`), replacement (`position="replace"`), or attribute modification (`position="attributes"`) within existing XML view structures.
-   **Custom Widgets:** New JavaScript widgets can be integrated into XML views by specifying `widget="my_custom_widget_name"` on a `<field>` tag or directly using `<widget name="my_custom_widget_name"/>`.

## 6. Action Manager
-   Handles various actions triggered by the backend (e.g., opening a form view, a report, a wizard).
-   Developers can register custom action types in `registry.category("actions")` to define new behaviors.

## 7. Debugging
-   **Browser Developer Tools:** The most important tool. Use the Console for JS errors/logs, Sources for breakpoints and code stepping, Network for RPC calls, and Elements for DOM/CSS inspection.
-   **`odoo.debug=assets`:** Adding this to the URL (`?debug=assets`) or enabling debug mode with assets will load JS files individually, making debugging easier.
-   **`console.log()` / `debugger;`:** Essential for inspecting values and pausing execution.
==================== END: odoo-web-framework-guide ====================

==================== START: odoo-website-guide ====================
# Odoo Website Development Guide

Odoo's Website module allows building dynamic, customizable public websites directly from Odoo. It leverages QWeb, Python controllers, and a block-based editor.

## 1. Website Structure
-   **Templates (`ir.ui.view`):** All website pages and components are ultimately QWeb templates stored as `ir.ui.view` records.
-   **Layout Template (`website.layout`):** The base template for all website pages. Custom pages usually extend or call this.
-   **Theme:** A collection of views, assets (CSS/JS), and data that define the look and feel of the website. Themes are Odoo modules.

## 2. Page Creation
-   **Static Pages:** Defined directly in XML as QWeb templates (e.g., `views/my_page.xml`). They are loaded into `website.layout`.
-   **Dynamic Pages:** Rendered by Python controllers (`http.Controller`). The controller fetches data from Odoo models and passes it to a QWeb template for rendering.

## 3. Themes
-   **Module Structure:** A theme is an Odoo module with a `views/` directory (for templates), `static/src/scss/` (for CSS), `static/src/js/` (for JS), and a `__manifest__.py` file declaring it as a theme (`'application': True`, `'category': 'Theme/...'`).
-   **Inheritance:** Themes often inherit from `website.theme_common` or other themes.
-   **Asset Bundles:** Frontend assets are typically defined in `web.assets_frontend` or `web.assets_website`.

## 4. Snippets (Building Blocks)
-   **Definition:** Reusable content blocks that users can drag and drop onto website pages in edit mode.
-   **Implementation:** Consists of:
    1.  **QWeb Template:** Defines the HTML structure of the snippet (`<template id="..." name="...">`).
    2.  **`snippet_options`:** XML to define the editor-side customization options for the snippet (e.g., background color, text alignment).
    3.  **JavaScript (Optional):** For interactive snippet behavior on the frontend.
-   **Registration:** Snippets are typically registered in `views/snippets.xml` and `views/options.xml`.

## 5. Python Controllers (`http.Controller`)
-   **Purpose:** Handle URL routes, fetch data from Odoo backend, process form submissions, and render QWeb templates for website pages.
-   **Decorators:**
    -   `@http.route`: Defines the URL route, HTTP methods, and authentication (`auth='public'`, `auth='user'`, `auth='none'`).
    -   `website=True`: Marks the route as part of the website, enabling website-specific features like `website.layout` and `s_website_slides`.
-   **`request` object:** Provides access to Odoo environment, current user, HTTP request details, and more.
-   **`request.render()`:** Used to render a QWeb template and pass data to it.

## 6. Frontend JavaScript (`web.assets_frontend`)
-   For interactive elements on the website, custom JavaScript can be included in `web.assets_frontend`.
-   Can use jQuery (still common in Odoo frontend), OWL components, or vanilla JS.

## 7. Styling (SCSS)
-   Odoo uses SCSS for styling the website. Custom themes will typically have their own SCSS files.
-   Variables defined in `website.theme_customize_options` can be used to allow users to customize colors/fonts via the website editor.

## 8. Debugging
-   **Browser Developer Tools:** Inspect HTML, CSS, JavaScript errors.
-   **Clearing Cache:** Always clear browser cache (Ctrl+F5 or Cmd+R) after making frontend changes.
-   **Odoo Debug Mode:** Activate developer mode for more insights.
-   **Server Logs:** Check Odoo server logs for Python controller errors.
==================== END: odoo-website-guide ====================

==================== START: odoo-pos-customization-guide ====================
# Odoo Point of Sale (PoS) Customization Guide

Odoo's Point of Sale is a highly customizable, offline-first web application. Customizations primarily involve extending its JavaScript framework.

## 1. PoS Architecture (JavaScript)
-   **Models:** The PoS system has its own client-side JavaScript models (e.g., `Order`, `Orderline`, `Product`, `CashRegister`) that mirror backend Odoo models. These are defined in `point_of_sale/static/src/js/models.js`.
-   **Screens:** Represent different views in the PoS interface (e.g., `ProductScreen`, `PaymentScreen`, `ReceiptScreen`).
-   **Widgets/Components:** Smaller reusable UI elements.
-   **Core Modules:** PoS is a large JavaScript application; understanding its core modules (`models.js`, `chrome.js`, `screens.js`) is crucial.

## 2. Module Structure & Assets
-   **Dependency:** Your custom module must have `point_of_sale` as a dependency in `__manifest__.py`.
-   **Assets:** PoS frontend assets (JS, XML) are loaded via the `point_of_sale.assets` bundle in `__manifest__.py`.
    -   `static/src/js/`: Your custom PoS JavaScript files.
    -   `static/src/xml/`: Your custom PoS QWeb templates.
    -   `static/src/scss/`: Your custom PoS styling.

## 3. Extending PoS JavaScript (Patching)
-   **`patch`:** For Odoo versions using OWL in PoS (Odoo 14+), the `patch` function (from `@web/core/utils/patch`) is the standard way to extend existing classes/components.
    -   Example: `patch(Order.prototype, 'my_module.OrderPatch', { ... });`
-   **`Class.include` (Older PoS):** For Odoo 13 and earlier, the `Class.include` method was used to extend JavaScript classes.
-   **Common Extensions:**
    -   Adding custom fields to PoS models (e.g., `Order`, `Orderline`) and ensuring they are saved/loaded correctly via `export_as_json` and `init_from_JSON`.
    -   Overriding existing methods (e.g., `_addOrderLine`, `_processOrder`).
    -   Creating custom buttons on screens and handling their logic.
    -   Developing new PoS screens or popups.

## 4. QWeb Templating for PoS
-   **HTML Structure:** PoS UI is defined using QWeb templates.
-   **Extension:** You can extend existing PoS QWeb templates (`t-extend` with `xpath`) to inject custom HTML, buttons, or modify existing elements.
-   **New Templates:** Create new QWeb templates for custom screens, popups, or widgets.

## 5. Python Backend for PoS
-   **Data Loading:** To make custom data available in the PoS frontend, you often need to override `_loader_params` methods or `_get_pos_ui_product` (for products) in the backend `pos.config` model to include your fields.
-   **Saving Data:** When new data needs to be saved from PoS to Odoo, you typically create a custom Python method (e.g., on `pos.order`) that can be called via RPC from the frontend.

## 6. RPC (Remote Procedure Calls)
-   PoS uses RPC calls to synchronize data with the Odoo backend (e.g., sending orders, fetching product updates).
-   Custom RPC calls can be made using `this.env.services.rpc` to interact with custom backend methods.

## 7. Debugging PoS
-   **Browser Developer Tools:** Essential.
    -   **Console:** For JavaScript errors, `console.log` outputs.
    -   **Sources:** Set breakpoints in your custom JS files to step through code.
    -   **Network:** Monitor RPC calls for request/response details.
    -   **Application:** Crucial for PoS. Inspect `IndexedDB` (for offline data) and `Local Storage` to see the client-side database.
-   **Clearing PoS Cache:** Go to `Point of Sale > Configuration > Point of Sale`, open your PoS, and click "Clear Cache" or refresh browser (Ctrl+F5) to ensure latest assets are loaded. This is *very* important as PoS aggressively caches.
-   **Offline Mode:** Test your customizations in both online and offline scenarios.

## 8. Common Customization Areas
-   Adding fields to order lines, products, or customers.
-   Custom buttons for actions (e.g., applying discounts, custom reports).
-   Integration with external hardware (e.g., scales, custom printers).
-   Custom payment methods.
-   Modifying product display or search behavior.
==================== END: odoo-pos-customization-guide ====================